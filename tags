!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Go	package	/the real package specified by the package name/
!_TAG_FIELD_DESCRIPTION!Go	packageName	/the name for referring the package/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!DTD	E,entity	/entities/
!_TAG_KIND_DESCRIPTION!DTD	a,attribute	/attributes/
!_TAG_KIND_DESCRIPTION!DTD	e,element	/elements/
!_TAG_KIND_DESCRIPTION!DTD	n,notation	/notations/
!_TAG_KIND_DESCRIPTION!DTD	p,parameterEntity	/parameter entities/
!_TAG_KIND_DESCRIPTION!Go	M,anonMember	/struct anonymous members/
!_TAG_KIND_DESCRIPTION!Go	P,packageName	/name for specifying imported package/
!_TAG_KIND_DESCRIPTION!Go	Y,unknown	/unknown/
!_TAG_KIND_DESCRIPTION!Go	a,talias	/type aliases/
!_TAG_KIND_DESCRIPTION!Go	c,const	/constants/
!_TAG_KIND_DESCRIPTION!Go	f,func	/functions/
!_TAG_KIND_DESCRIPTION!Go	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!Go	m,member	/struct members/
!_TAG_KIND_DESCRIPTION!Go	n,methodSpec	/interface method specification/
!_TAG_KIND_DESCRIPTION!Go	p,package	/packages/
!_TAG_KIND_DESCRIPTION!Go	s,struct	/structs/
!_TAG_KIND_DESCRIPTION!Go	t,type	/types/
!_TAG_KIND_DESCRIPTION!Go	v,var	/variables/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!DTD	0.0	/current.age/
!_TAG_PARSER_VERSION!Go	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/Users/tlincke/Development/ndbgo/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	//
!_TAG_ROLE_DESCRIPTION!DTD!element	attOwner	/attributes owner/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	condition	/conditions/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	elementName	/element names/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	partOfAttDef	/part of attribute definition/
!_TAG_ROLE_DESCRIPTION!Go!package	imported	/imported package/
!_TAG_ROLE_DESCRIPTION!Go!unknown	receiverType	/receiver type/
Assert	internal/utils/assert.go	/^func Assert(cond bool) {$/;"	f	package:utils
Cause	internal/nserror/nserror.go	/^	Cause    error$/;"	m	struct:nserror.DomainError	typeref:typename:error
Close	internal/numstore/variable.go	/^func (v WritingVariable) Close() error {$/;"	f	struct:numstore.WritingVariable	typeref:typename:error
CloseWriteContext	internal/numstore/writer.go	/^func (w OpenWriteContext) CloseWriteContext() error {$/;"	f	struct:numstore.OpenWriteContext	typeref:typename:error
Code	internal/nserror/nserror.go	/^	Code     int$/;"	m	struct:nserror.DomainError	typeref:typename:int
ConnectingToVarWithoutDB	internal/nserror/nserror.go	/^	ConnectingToVarWithoutDB = New(6, "cannot connect variable without a database")$/;"	v	package:nserror
ConnectionInvalidState	internal/nserror/nserror.go	/^	ConnectionInvalidState   = New(3, "invalid connection state")$/;"	v	package:nserror
CreateDatabase	internal/numstore/database.go	/^func CreateDatabase(name string) error {$/;"	f	package:numstore	typeref:typename:error
CreateVariable	internal/numstore/variable.go	/^func CreateVariable(dbname string, v VariableMeta) error {$/;"	f	package:numstore	typeref:typename:error
DBAlreadyConnected	internal/nserror/nserror.go	/^	DBAlreadyConnected       = New(4, "database already connected")$/;"	v	package:nserror
DBAlreadyExists	internal/nserror/nserror.go	/^	DBAlreadyExists          = New(1, "database already exists")$/;"	v	package:nserror
DBNotConnected	internal/nserror/nserror.go	/^	DBNotConnected           = New(2, "database not connected")$/;"	v	package:nserror
Database	internal/numstore/database.go	/^type Database struct {$/;"	s	package:numstore
Dbname	internal/numstore/writer.go	/^	Dbname    string$/;"	m	struct:numstore.WriteContextRequest	typeref:typename:string
Default	internal/numstore/property.go	/^  Default() PropertyType $/;"	n	interface:numstore.PropertyTypeFactory	typeref:typename:PropertyType
DomainError	internal/nserror/nserror.go	/^type DomainError struct {$/;"	s	package:nserror
Dtype	internal/numstore/dtype.go	/^type Dtype uint16$/;"	t	package:numstore	typeref:typename:uint16
Dtype	internal/numstore/variable.go	/^	Dtype Dtype    `json:"dtype"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:Dtype
Error	internal/nserror/nserror.go	/^func (e *DomainError) Error() string {$/;"	f	struct:nserror.DomainError	typeref:typename:string
FileExists	internal/utils/fs.go	/^func FileExists(name string) (os.FileInfo, error) {$/;"	f	package:utils	typeref:typename:(os.FileInfo, error)
InvalidDBName	internal/nserror/nserror.go	/^	InvalidDBName            = New(8, "invalid database name")$/;"	v	package:nserror
InvalidVarName	internal/nserror/nserror.go	/^	InvalidVarName           = New(7, "invalid variable name")$/;"	v	package:nserror
JSONInvalidDtype	internal/nserror/nserror.go	/^	JSONInvalidDtype         = New(11, "invalid dtype for JSON")$/;"	v	package:nserror
Key	internal/numstore/property.go	/^  Key() string$/;"	n	interface:numstore.PropertyTypeFactory	typeref:typename:string
LoadVariableMeta	internal/numstore/variable.go	/^func LoadVariableMeta(dbname, vname string) (VariableMeta, error) {$/;"	f	package:numstore	typeref:typename:(VariableMeta, error)
MarshalJSON	internal/numstore/dtype.go	/^func (d Dtype) MarshalJSON() ([]byte, error) {$/;"	f	type:numstore.Dtype	typeref:typename:([]byte, error)
Messages	internal/nserror/nserror.go	/^	Messages []string$/;"	m	struct:nserror.DomainError	typeref:typename:[]string
Name	internal/numstore/database.go	/^	Name  string `json:"name"`$/;"	m	struct:numstore.Database	typeref:typename:string
Name	internal/numstore/variable.go	/^	Name  string   `json:"name"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:string
New	internal/nserror/nserror.go	/^func New(code int, msg string) error {$/;"	f	package:nserror	typeref:typename:error
NotConnectedToDB	internal/nserror/nserror.go	/^	NotConnectedToDB         = New(9, "not connected to database")$/;"	v	package:nserror
OpenVariable	internal/numstore/variable.go	/^func OpenVariable(dbname string, v VariableMeta) (WritingVariable, error) {$/;"	f	package:numstore	typeref:typename:(WritingVariable, error)
OpenWriteContext	internal/numstore/writer.go	/^func (w WriteContext) OpenWriteContext() (OpenWriteContext, error) {$/;"	f	struct:numstore.WriteContext	typeref:typename:(OpenWriteContext, error)
OpenWriteContext	internal/numstore/writer.go	/^type OpenWriteContext struct {$/;"	s	package:numstore
OpenWriteContextRequest	internal/numstore/writer.go	/^func (w WriteContextRequest) OpenWriteContextRequest() (WriteContext, error) {$/;"	f	struct:numstore.WriteContextRequest	typeref:typename:(WriteContext, error)
Parse	internal/numstore/property.go	/^  Parse(json string) string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
PrettyString	internal/numstore/property.go	/^	PrettyString() string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
PropertyType	internal/numstore/property.go	/^type PropertyType interface {$/;"	i	package:numstore
PropertyTypeFactory	internal/numstore/property.go	/^type PropertyTypeFactory interface {$/;"	i	package:numstore
ReduceMultU32	internal/utils/arrays.go	/^func ReduceMultU32(arr []uint32) uint32 {$/;"	f	package:utils	typeref:typename:uint32
Register	internal/numstore/property.go	/^func Register(factory PropertyTypeFactory) {$/;"	f	package:numstore
Serialize	internal/numstore/property.go	/^  Serialize() string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
Shape	internal/numstore/variable.go	/^	Shape []uint32 `json:"shape"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:[]uint32
String	internal/numstore/dtype.go	/^func (d Dtype) String() string {$/;"	f	type:numstore.Dtype	typeref:typename:string
ToWrite	internal/numstore/writer.go	/^	ToWrite   int$/;"	m	struct:numstore.WriteContextRequest	typeref:typename:int
U16	internal/numstore/dtype.go	/^	U16 Dtype = iota$/;"	c	package:numstore	typeref:type:Dtype
U32	internal/numstore/dtype.go	/^	U32 $/;"	c	package:numstore
U64	internal/numstore/dtype.go	/^  U64$/;"	c	package:numstore
UnmarshalJSON	internal/numstore/dtype.go	/^func (d *Dtype) UnmarshalJSON(data []byte) error {$/;"	f	type:numstore.Dtype	typeref:typename:error
VarAlreadyConnected	internal/nserror/nserror.go	/^	VarAlreadyConnected      = New(5, "variable already connected")$/;"	v	package:nserror
VarAlreadyExists	internal/nserror/nserror.go	/^	VarAlreadyExists         = New(10, "variable already exists")$/;"	v	package:nserror
VariableMeta	internal/numstore/variable.go	/^type VariableMeta struct {$/;"	s	package:numstore
Variables	internal/numstore/writer.go	/^	Variables [][]string$/;"	m	struct:numstore.WriteContextRequest	typeref:typename:[][]string
Wrapf	internal/nserror/nserror.go	/^func Wrapf(err error, format string, args ...any) error {$/;"	f	package:nserror	typeref:typename:error
WriteAll	internal/numstore/writer.go	/^func (w OpenWriteContext) WriteAll(r io.Reader) error {$/;"	f	struct:numstore.OpenWriteContext	typeref:typename:error
WriteContext	internal/numstore/writer.go	/^type WriteContext struct {$/;"	s	package:numstore
WriteContextRequest	internal/numstore/writer.go	/^type WriteContextRequest struct {$/;"	s	package:numstore
WriteContext_DuplicateVar	internal/nserror/nserror.go	/^	WriteContext_DuplicateVar = New(12, "Invalid Write context, duplicate variable")$/;"	v	package:nserror
WriteNext	internal/numstore/variable.go	/^func (v WritingVariable) WriteNext(r io.Reader, t uint64) error {$/;"	f	struct:numstore.WritingVariable	typeref:typename:error
WritingVariable	internal/numstore/variable.go	/^type WritingVariable struct {$/;"	s	package:numstore
createDbFolder	internal/numstore/database.go	/^func createDbFolder(v Database) error {$/;"	f	package:numstore	typeref:typename:error
createDbMetaFile	internal/numstore/database.go	/^func createDbMetaFile(v Database) error {$/;"	f	package:numstore	typeref:typename:error
createVarFolder	internal/numstore/variable.go	/^func createVarFolder(dbname, vname string) error {$/;"	f	package:numstore	typeref:typename:error
createVarMetaFile	internal/numstore/variable.go	/^func createVarMetaFile(dbname string, v VariableMeta) error {$/;"	f	package:numstore	typeref:typename:error
dataBuffer	internal/numstore/variable.go	/^	dataBuffer []byte$/;"	m	struct:numstore.WritingVariable	typeref:typename:[]byte
dbExistsAndValid	internal/numstore/database.go	/^func dbExistsAndValid(d Database) (bool, error) {$/;"	f	package:numstore	typeref:typename:(bool, error)
dbFolderName	internal/numstore/database.go	/^func dbFolderName(d Database) string {$/;"	f	package:numstore	typeref:typename:string
dbMetaFileName	internal/numstore/database.go	/^func dbMetaFileName(d Database) string {$/;"	f	package:numstore	typeref:typename:string
dbname	internal/numstore/writer.go	/^	dbname    string$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:string
dbname	internal/numstore/writer.go	/^	dbname    string$/;"	m	struct:numstore.WriteContext	typeref:typename:string
dtypeSizeof	internal/numstore/dtype.go	/^func dtypeSizeof(dtype Dtype) uint32 {$/;"	f	package:numstore	typeref:typename:uint32
enableAsserts	internal/utils/assert.go	/^const enableAsserts = true$/;"	c	package:utils
extractCode	internal/nserror/nserror.go	/^func extractCode(err error) int {$/;"	f	package:nserror	typeref:typename:int
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
nserror	internal/nserror/nserror.go	/^package nserror$/;"	p
numstore	internal/numstore/database.go	/^package numstore$/;"	p
numstore	internal/numstore/dtype.go	/^package numstore$/;"	p
numstore	internal/numstore/numstore.go	/^package numstore$/;"	p
numstore	internal/numstore/property.go	/^package numstore$/;"	p
numstore	internal/numstore/stream.go	/^package numstore$/;"	p
numstore	internal/numstore/variable.go	/^package numstore$/;"	p
numstore	internal/numstore/writer.go	/^package numstore$/;"	p
propTypeRegistry	internal/numstore/property.go	/^var propTypeRegistry = make(map[string]PropertyTypeFactory)$/;"	v	package:numstore
tfd	internal/numstore/variable.go	/^	tfd        *os.File$/;"	m	struct:numstore.WritingVariable	typeref:typename:*os.File
timeBuffer	internal/numstore/variable.go	/^	timeBuffer []byte$/;"	m	struct:numstore.WritingVariable	typeref:typename:[]byte
toWrite	internal/numstore/writer.go	/^	toWrite   int$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:int
toWrite	internal/numstore/writer.go	/^	toWrite   int$/;"	m	struct:numstore.WriteContext	typeref:typename:int
utils	internal/utils/arrays.go	/^package utils$/;"	p
utils	internal/utils/assert.go	/^package utils$/;"	p
utils	internal/utils/fs.go	/^package utils$/;"	p
varDataFileName	internal/numstore/variable.go	/^func varDataFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varExistsAndValid	internal/numstore/variable.go	/^func varExistsAndValid(db, v string) (bool, error) {$/;"	f	package:numstore	typeref:typename:(bool, error)
varFolderName	internal/numstore/variable.go	/^func varFolderName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varMetaFileName	internal/numstore/variable.go	/^func varMetaFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varTimeFileName	internal/numstore/variable.go	/^func varTimeFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
variables	internal/numstore/writer.go	/^	variables [][]VariableMeta$/;"	m	struct:numstore.WriteContext	typeref:typename:[][]VariableMeta
variables	internal/numstore/writer.go	/^	variables [][]WritingVariable$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:[][]WritingVariable
vfd	internal/numstore/variable.go	/^	vfd        *os.File$/;"	m	struct:numstore.WritingVariable	typeref:typename:*os.File
