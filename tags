!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/theo/Development/ndbgo/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
1.0 Numstore Technical Manual	MANUAL.md	/^# 1.0 Numstore Technical Manual$/;"	c
1.1.0 Features	MANUAL.md	/^## 1.1.0 Features$/;"	s	chapter:1.0 Numstore Technical Manual
1.1.1.0 Creating Variables	MANUAL.md	/^### 1.1.1.0 Creating Variables $/;"	S	section:1.0 Numstore Technical Manual""1.1.0 Features
1.1.1.0 Reading	MANUAL.md	/^### 1.1.1.0 Reading$/;"	S	section:1.0 Numstore Technical Manual""1.1.0 Features
1.1.1.0 Writing	MANUAL.md	/^### 1.1.1.0 Writing$/;"	S	section:1.0 Numstore Technical Manual""1.1.0 Features
Assert	internal/utils/assert.go	/^func Assert(cond bool) {$/;"	f	package:utils
Bool	internal/numstore/nstypes.go	/^	Bool$/;"	c	package:numstore
BytesToUInt32Arr	internal/utils/numbers.go	/^func BytesToUInt32Arr(b []byte) []uint32 {$/;"	f	package:utils	typeref:typename:[]uint32
CF128	internal/numstore/nstypes.go	/^	CF128$/;"	c	package:numstore
CF256	internal/numstore/nstypes.go	/^	CF256$/;"	c	package:numstore
CF32	internal/numstore/nstypes.go	/^	CF32$/;"	c	package:numstore
CF64	internal/numstore/nstypes.go	/^	CF64$/;"	c	package:numstore
CanIntBeByte	internal/utils/numbers.go	/^func CanIntBeByte(n int) bool {$/;"	f	package:utils	typeref:typename:bool
CanUint64BeUint32	internal/utils/numbers.go	/^func CanUint64BeUint32(n uint64) bool {$/;"	f	package:utils	typeref:typename:bool
Char	internal/numstore/nstypes.go	/^	Char$/;"	c	package:numstore
Close	internal/numstore/variable.go	/^func (v WritingVariable) Close() error {$/;"	f	struct:numstore.WritingVariable	typeref:typename:error
CloseWriteContext	internal/numstore/writing.go	/^func (w OpenWriteContext) CloseWriteContext() error {$/;"	f	struct:numstore.OpenWriteContext	typeref:typename:error
Create	main.md	/^# Create $/;"	c
CreateDatabase	internal/numstore/database.go	/^func CreateDatabase(name string) error {$/;"	f	package:numstore	typeref:typename:error
CreateVariable	internal/numstore/variable.go	/^func CreateVariable(dbname string, v VariableMeta) error {$/;"	f	package:numstore	typeref:typename:error
DEBUG	internal/logging/logging.go	/^	DEBUG$/;"	c	package:logging
Database	internal/numstore/database.go	/^type Database struct {$/;"	s	package:numstore
Dbname	internal/numstore/reader.go	/^	Dbname         string$/;"	m	struct:numstore.ReadContextRequest	typeref:typename:string
Dbname	internal/numstore/writing.go	/^	Dbname    string$/;"	m	struct:numstore.WriteFormat2	typeref:typename:string
Debug	internal/logging/logging.go	/^func Debug(fmt string, msg ...any) {$/;"	f	package:logging
Debug	internal/utils/config.go	/^const Debug = true$/;"	c	package:utils
Default	internal/numstore/property.go	/^  Default() PropertyType $/;"	n	interface:numstore.PropertyTypeFactory	typeref:typename:PropertyType
Delete	main.md	/^# Delete $/;"	c
Dims	internal/numstore/nstypes.go	/^	Dims []uint32 `json:"dims"`$/;"	m	struct:numstore.StrictArrayType	typeref:typename:[]uint32
Dtype	internal/numstore/variable.go	/^	Dtype primitiveType `json:"dtype"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:primitiveType
ERROR	internal/logging/logging.go	/^	ERROR$/;"	c	package:logging
Endian	internal/utils/config.go	/^var Endian = binary.LittleEndian$/;"	v	package:utils
EnumKind	internal/numstore/nstypes.go	/^	EnumKind        NSTypeKind = "enum"$/;"	c	package:numstore	typeref:type:NSTypeKind
EnumType	internal/numstore/nstypes.go	/^type EnumType struct {$/;"	s	package:numstore
Error	internal/logging/logging.go	/^func Error(fmt string, msg ...any) {$/;"	f	package:logging
ErrorContext	internal/nserror/nserror.go	/^func ErrorContext(err error) error {$/;"	f	package:nserror	typeref:typename:error
ErrorMoref	internal/nserror/nserror.go	/^func ErrorMoref(cause error, msg string, args ...any) error {$/;"	f	package:nserror	typeref:typename:error
ErrorStack	internal/nserror/nserror.go	/^func ErrorStack(cause error) error {$/;"	f	package:nserror	typeref:typename:error
F128	internal/numstore/nstypes.go	/^	F128$/;"	c	package:numstore
F16	internal/numstore/nstypes.go	/^	F16$/;"	c	package:numstore
F32	internal/numstore/nstypes.go	/^	F32$/;"	c	package:numstore
F64	internal/numstore/nstypes.go	/^	F64$/;"	c	package:numstore
FATAL	internal/logging/logging.go	/^	FATAL$/;"	c	package:logging
Fields	internal/numstore/nstypes.go	/^	Fields map[string]Type `json:"fields"`$/;"	m	struct:numstore.StructType	typeref:typename:map[string]Type
Fields	internal/numstore/nstypes.go	/^	Fields map[string]Type `json:"fields"`$/;"	m	struct:numstore.UnionType	typeref:typename:map[string]Type
FileExists	internal/utils/fs.go	/^func FileExists(name string) (os.FileInfo, error) {$/;"	f	package:utils	typeref:typename:(os.FileInfo, error)
FileRun	internal/frontend/file.go	/^func FileRun(fname, dbname string) {$/;"	f	package:nsfrontend
GetFunctionName	internal/utils/reflection.go	/^func GetFunctionName(skip int) string {$/;"	f	package:utils	typeref:typename:string
I128	internal/numstore/nstypes.go	/^	I128$/;"	c	package:numstore
I16	internal/numstore/nstypes.go	/^	I16$/;"	c	package:numstore
I32	internal/numstore/nstypes.go	/^	I32$/;"	c	package:numstore
I64	internal/numstore/nstypes.go	/^	I64$/;"	c	package:numstore
I8	internal/numstore/nstypes.go	/^	I8 primitiveType = iota$/;"	c	package:numstore	typeref:type:primitiveType
INFO	internal/logging/logging.go	/^	INFO$/;"	c	package:logging
Info	internal/logging/logging.go	/^func Info(fmt string, msg ...any) {$/;"	f	package:logging
IntCanPlus	internal/utils/numbers.go	/^func IntCanPlus(a int, b int) bool {$/;"	f	package:utils	typeref:typename:bool
IntPlusWillOverflow	internal/utils/numbers.go	/^func IntPlusWillOverflow(a int, b int) bool {$/;"	f	package:utils	typeref:typename:bool
IntPlusWillUnderflow	internal/utils/numbers.go	/^func IntPlusWillUnderflow(a int, b int) bool {$/;"	f	package:utils	typeref:typename:bool
IntToUint32	internal/utils/numbers.go	/^func IntToUint32(arr []int) ([]uint32, error) {$/;"	f	package:utils	typeref:typename:([]uint32, error)
Invariants	main.md	/^# Invariants $/;"	c
IsAlpha	internal/utils/strings.go	/^func IsAlpha(c byte) bool {$/;"	f	package:utils	typeref:typename:bool
IsAlphaNum	internal/utils/strings.go	/^func IsAlphaNum(c byte) bool {$/;"	f	package:utils	typeref:typename:bool
IsDigit	internal/utils/strings.go	/^func IsDigit(c byte) bool {$/;"	f	package:utils	typeref:typename:bool
Key	internal/numstore/property.go	/^  Key() string$/;"	n	interface:numstore.PropertyTypeFactory	typeref:typename:string
Kind	internal/numstore/nstypes.go	/^	Kind() NSTypeKind$/;"	n	interface:numstore.Type	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (EnumType) Kind() NSTypeKind        { return EnumKind }$/;"	f	struct:numstore.EnumType	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (PrimitiveType) Kind() NSTypeKind   { return PrimKind }$/;"	f	struct:numstore.PrimitiveType	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (StrictArrayType) Kind() NSTypeKind { return StrictArrayKind }$/;"	f	struct:numstore.StrictArrayType	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (StructType) Kind() NSTypeKind      { return StructKind }$/;"	f	struct:numstore.StructType	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (UnionType) Kind() NSTypeKind       { return UnionKind }$/;"	f	struct:numstore.UnionType	typeref:typename:NSTypeKind
Kind	internal/numstore/nstypes.go	/^func (VarArrayType) Kind() NSTypeKind    { return VarArrayKind }$/;"	f	struct:numstore.VarArrayType	typeref:typename:NSTypeKind
LoadVariableMeta	internal/numstore/variable.go	/^func LoadVariableMeta(dbname, vname string) (VariableMeta, error) {$/;"	f	package:numstore	typeref:typename:(VariableMeta, error)
LogLevel	internal/logging/logging.go	/^type LogLevel int$/;"	t	package:logging	typeref:typename:int
MarshalJSON	internal/numstore/nstypes.go	/^func (d primitiveType) MarshalJSON() ([]byte, error) {$/;"	f	type:numstore.primitiveType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (e EnumType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.EnumType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (p PrimitiveType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.PrimitiveType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (s StructType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.StructType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (t StrictArrayType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.StrictArrayType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (t VarArrayType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.VarArrayType	typeref:typename:([]byte, error)
MarshalJSON	internal/numstore/nstypes.go	/^func (u UnionType) MarshalJSON() ([]byte, error) {$/;"	f	struct:numstore.UnionType	typeref:typename:([]byte, error)
NSTypeKind	internal/numstore/nstypes.go	/^type NSTypeKind string$/;"	t	package:numstore	typeref:typename:string
Name	internal/numstore/database.go	/^	Name string `json:"name"`$/;"	m	struct:numstore.Database	typeref:typename:string
Name	internal/numstore/variable.go	/^	Name  string        `json:"name"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:string
Of	internal/numstore/nstypes.go	/^	Of   Type     `json:"of"`$/;"	m	struct:numstore.StrictArrayType	typeref:typename:Type
Of	internal/numstore/nstypes.go	/^	Of   Type   `json:"of"`$/;"	m	struct:numstore.VarArrayType	typeref:typename:Type
Open	main.md	/^# Open$/;"	c
OpenVariable	internal/numstore/variable.go	/^func OpenVariable(dbname string, v VariableMeta) (WritingVariable, error) {$/;"	f	package:numstore	typeref:typename:(WritingVariable, error)
OpenWriteContext	internal/numstore/writing.go	/^func (w WriteContext) OpenWriteContext() (OpenWriteContext, error) {$/;"	f	struct:numstore.WriteContext	typeref:typename:(OpenWriteContext, error)
OpenWriteContext	internal/numstore/writing.go	/^type OpenWriteContext struct {$/;"	s	package:numstore
OpenWriteFormat2	internal/numstore/writing.go	/^func (w WriteFormat2) OpenWriteFormat2() (WriteContext, error) {$/;"	f	struct:numstore.WriteFormat2	typeref:typename:(WriteContext, error)
Options	internal/numstore/nstypes.go	/^	Options []string `json:"options"`$/;"	m	struct:numstore.EnumType	typeref:typename:[]string
PT	internal/numstore/nstypes.go	/^	PT primitiveType `json:"type"`$/;"	m	struct:numstore.PrimitiveType	typeref:typename:primitiveType
Parse	internal/compiler/parser.go	/^func Parse(tokens []token) error {$/;"	f	package:compiler	typeref:typename:error
Parse	internal/numstore/property.go	/^  Parse(json string) string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
ParseUInt32Slice	internal/utils/numbers.go	/^func ParseUInt32Slice(input string) ([]uint32, error) {$/;"	f	package:utils	typeref:typename:([]uint32, error)
PrettyString	internal/numstore/property.go	/^	PrettyString() string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
PrimKind	internal/numstore/nstypes.go	/^	PrimKind        NSTypeKind = "primitive"$/;"	c	package:numstore	typeref:type:NSTypeKind
PrimitiveType	internal/numstore/nstypes.go	/^type PrimitiveType struct {$/;"	s	package:numstore
PrimitiveTypeFromString	internal/numstore/nstypes.go	/^func PrimitiveTypeFromString(s string) (primitiveType, bool) {$/;"	f	package:numstore	typeref:typename:(primitiveType, bool)
ProgramName	internal/utils/config.go	/^var ProgramName = "NDB"$/;"	v	package:utils
PropertyType	internal/numstore/property.go	/^type PropertyType interface {$/;"	i	package:numstore
PropertyTypeFactory	internal/numstore/property.go	/^type PropertyTypeFactory interface {$/;"	i	package:numstore
Range	internal/numstore/range.go	/^type Range struct {$/;"	s	package:numstore
Rank	internal/numstore/nstypes.go	/^	Rank uint32 `json:"rank"`$/;"	m	struct:numstore.VarArrayType	typeref:typename:uint32
Read	main.md	/^# Read$/;"	c
ReadContextRequest	internal/numstore/reader.go	/^type ReadContextRequest struct {$/;"	s	package:numstore
ReadFile	internal/utils/fs.go	/^func ReadFile(path string) ([]byte, error) {$/;"	f	package:utils	typeref:typename:([]byte, error)
ReduceMultU32	internal/utils/arrays.go	/^func ReduceMultU32(arr []uint32) uint32 {$/;"	f	package:utils	typeref:typename:uint32
Register	internal/numstore/property.go	/^func Register(factory PropertyTypeFactory) {$/;"	f	package:numstore
Scan	internal/compiler/scanner.go	/^func Scan(data string) []token {$/;"	f	package:compiler	typeref:typename:[]token
Serialize	internal/numstore/property.go	/^  Serialize() string$/;"	n	interface:numstore.PropertyType	typeref:typename:string
Shape	internal/numstore/variable.go	/^	Shape []uint32      `json:"shape"`$/;"	m	struct:numstore.VariableMeta	typeref:typename:[]uint32
ShellRun	internal/frontend/shell.go	/^func ShellRun(dbName string) {$/;"	f	package:nsfrontend
StrictArrayKind	internal/numstore/nstypes.go	/^	StrictArrayKind NSTypeKind = "strict_array"$/;"	c	package:numstore	typeref:type:NSTypeKind
StrictArrayType	internal/numstore/nstypes.go	/^type StrictArrayType struct {$/;"	s	package:numstore
String	internal/compiler/tokens.go	/^func (t token) String() string {$/;"	f	struct:compiler.token	typeref:typename:string
String	internal/compiler/tokens.go	/^func (t tokenType) String() string {$/;"	f	type:compiler.tokenType	typeref:typename:string
String	internal/numstore/nstypes.go	/^func (d primitiveType) String() string {$/;"	f	type:numstore.primitiveType	typeref:typename:string
StructKind	internal/numstore/nstypes.go	/^	StructKind      NSTypeKind = "struct"$/;"	c	package:numstore	typeref:type:NSTypeKind
StructType	internal/numstore/nstypes.go	/^type StructType struct {$/;"	s	package:numstore
TOK_CLOSE	internal/compiler/tokens.go	/^	TOK_CLOSE$/;"	c	package:compiler
TOK_COLON	internal/numstore/range.go	/^	TOK_COLON$/;"	c	package:numstore
TOK_COMMA	internal/compiler/tokens.go	/^	TOK_COMMA$/;"	c	package:compiler
TOK_CREATE	internal/compiler/tokens.go	/^	TOK_CREATE$/;"	c	package:compiler
TOK_DELETE	internal/compiler/tokens.go	/^	TOK_DELETE$/;"	c	package:compiler
TOK_ENUM	internal/compiler/tokens.go	/^	TOK_ENUM$/;"	c	package:compiler
TOK_EOF	internal/compiler/tokens.go	/^	TOK_EOF$/;"	c	package:compiler
TOK_FLOAT	internal/compiler/tokens.go	/^	TOK_FLOAT$/;"	c	package:compiler
TOK_IDENTIFIER	internal/compiler/tokens.go	/^	TOK_IDENTIFIER$/;"	c	package:compiler
TOK_INTEGER	internal/compiler/tokens.go	/^	TOK_INTEGER$/;"	c	package:compiler
TOK_LEFT_BRACKET	internal/compiler/tokens.go	/^	TOK_LEFT_BRACKET$/;"	c	package:compiler
TOK_LEFT_BRACKET	internal/numstore/range.go	/^	TOK_LEFT_BRACKET parse_tok = iota$/;"	c	package:numstore	typeref:type:parse_tok
TOK_LEFT_CURLY	internal/compiler/tokens.go	/^	TOK_LEFT_CURLY$/;"	c	package:compiler
TOK_LEFT_PAREN	internal/compiler/tokens.go	/^	TOK_LEFT_PAREN$/;"	c	package:compiler
TOK_NONE	internal/compiler/tokens.go	/^	TOK_NONE tokenType = iota$/;"	c	package:compiler	typeref:type:tokenType
TOK_NUMBER	internal/numstore/range.go	/^	TOK_NUMBER$/;"	c	package:numstore
TOK_OPEN	internal/compiler/tokens.go	/^	TOK_OPEN$/;"	c	package:compiler
TOK_PRIM	internal/compiler/tokens.go	/^	TOK_PRIM$/;"	c	package:compiler
TOK_READ	internal/compiler/tokens.go	/^	TOK_READ$/;"	c	package:compiler
TOK_RIGHT_BRACKET	internal/compiler/tokens.go	/^	TOK_RIGHT_BRACKET$/;"	c	package:compiler
TOK_RIGHT_BRACKET	internal/numstore/range.go	/^	TOK_RIGHT_BRACKET$/;"	c	package:numstore
TOK_RIGHT_CURLY	internal/compiler/tokens.go	/^	TOK_RIGHT_CURLY$/;"	c	package:compiler
TOK_RIGHT_PAREN	internal/compiler/tokens.go	/^	TOK_RIGHT_PAREN$/;"	c	package:compiler
TOK_SEMICOLON	internal/compiler/tokens.go	/^	TOK_SEMICOLON$/;"	c	package:compiler
TOK_STRING	internal/compiler/tokens.go	/^	TOK_STRING$/;"	c	package:compiler
TOK_STRUCT	internal/compiler/tokens.go	/^	TOK_STRUCT$/;"	c	package:compiler
TOK_TAKE	internal/compiler/tokens.go	/^	TOK_TAKE$/;"	c	package:compiler
TOK_UNION	internal/compiler/tokens.go	/^	TOK_UNION$/;"	c	package:compiler
TOK_WRITE	internal/compiler/tokens.go	/^	TOK_WRITE$/;"	c	package:compiler
TRACE	internal/logging/logging.go	/^	TRACE LogLevel = iota$/;"	c	package:logging	typeref:type:LogLevel
Take	main.md	/^# Take$/;"	c
ToRead	internal/numstore/reader.go	/^	ToRead         int$/;"	m	struct:numstore.ReadContextRequest	typeref:typename:int
ToWrite	internal/numstore/writing.go	/^	ToWrite   int$/;"	m	struct:numstore.WriteFormat	typeref:typename:int
ToWrite	internal/numstore/writing.go	/^	ToWrite   int$/;"	m	struct:numstore.WriteFormat2	typeref:typename:int
Trace	internal/logging/logging.go	/^func Trace(fmt string, msg ...any) {$/;"	f	package:logging
Type	internal/numstore/nstypes.go	/^type Type interface {$/;"	i	package:numstore
U128	internal/numstore/nstypes.go	/^	U128$/;"	c	package:numstore
U16	internal/numstore/nstypes.go	/^	U16$/;"	c	package:numstore
U32	internal/numstore/nstypes.go	/^	U32$/;"	c	package:numstore
U64	internal/numstore/nstypes.go	/^	U64$/;"	c	package:numstore
U8	internal/numstore/nstypes.go	/^	U8$/;"	c	package:numstore
UInt32ArrBytes	internal/utils/numbers.go	/^func UInt32ArrBytes(arr []uint32) []byte {$/;"	f	package:utils	typeref:typename:[]byte
UnionKind	internal/numstore/nstypes.go	/^	UnionKind       NSTypeKind = "union"$/;"	c	package:numstore	typeref:type:NSTypeKind
UnionType	internal/numstore/nstypes.go	/^type UnionType struct {$/;"	s	package:numstore
UnmarshalJSON	internal/numstore/nstypes.go	/^func (d *primitiveType) UnmarshalJSON(data []byte) error {$/;"	f	type:numstore.primitiveType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (e *EnumType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.EnumType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (p *PrimitiveType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.PrimitiveType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (s *StructType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.StructType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (t *StrictArrayType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.StrictArrayType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (t *VarArrayType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.VarArrayType	typeref:typename:error
UnmarshalJSON	internal/numstore/nstypes.go	/^func (u *UnionType) UnmarshalJSON(data []byte) error {$/;"	f	struct:numstore.UnionType	typeref:typename:error
VarArrayKind	internal/numstore/nstypes.go	/^	VarArrayKind    NSTypeKind = "var_array"$/;"	c	package:numstore	typeref:type:NSTypeKind
VarArrayType	internal/numstore/nstypes.go	/^type VarArrayType struct {$/;"	s	package:numstore
VariableMeta	internal/numstore/variable.go	/^type VariableMeta struct {$/;"	s	package:numstore
VariableSlice	internal/numstore/reader.go	/^type VariableSlice struct {$/;"	s	package:numstore
VariableSlices	internal/numstore/reader.go	/^	VariableSlices [][]string$/;"	m	struct:numstore.ReadContextRequest	typeref:typename:[][]string
Variables	internal/numstore/writing.go	/^	Variables [][]string$/;"	m	struct:numstore.WriteFormat	typeref:typename:[][]string
Variables	internal/numstore/writing.go	/^	Variables [][]string$/;"	m	struct:numstore.WriteFormat2	typeref:typename:[][]string
Version	internal/utils/config.go	/^var Version = "0.0.1-wip"$/;"	v	package:utils
VersionDate	internal/utils/config.go	/^var VersionDate = "2025-02-03 14:03:47"$/;"	v	package:utils
WARN	internal/logging/logging.go	/^	WARN$/;"	c	package:logging
Warn	internal/logging/logging.go	/^func Warn(fmt string, msg ...any) {$/;"	f	package:logging
Write	main.md	/^# Write $/;"	c
WriteAll	internal/numstore/writing.go	/^func (w OpenWriteContext) WriteAll(r io.Reader) error {$/;"	f	struct:numstore.OpenWriteContext	typeref:typename:error
WriteContext	internal/numstore/writing.go	/^type WriteContext struct {$/;"	s	package:numstore
WriteFormat	internal/numstore/writing.go	/^type WriteFormat struct {$/;"	s	package:numstore
WriteFormat2	internal/numstore/writing.go	/^type WriteFormat2 struct {$/;"	s	package:numstore
WriteNext	internal/numstore/variable.go	/^func (v WritingVariable) WriteNext(r io.Reader, t uint64) error {$/;"	f	struct:numstore.WritingVariable	typeref:typename:error
WritingVariable	internal/numstore/variable.go	/^type WritingVariable struct {$/;"	s	package:numstore
_ptToString	internal/numstore/nstypes.go	/^	_ptToString = map[primitiveType]string{$/;"	v	package:numstore
_stringToPT	internal/numstore/nstypes.go	/^	_stringToPT = func() map[string]primitiveType {$/;"	v	package:numstore
arrRange	internal/compiler/parseRange.go	/^type arrRange struct {$/;"	s	package:compiler
checkKeyword	internal/compiler/scanner.go	/^func (s *scanner) checkKeyword() tokenType {$/;"	f	struct:compiler.scanner	typeref:typename:tokenType
cleanInput	internal/frontend/common.go	/^func cleanInput(text string) string {$/;"	f	package:nsfrontend	typeref:typename:string
clearScreen	internal/frontend/shell.go	/^func clearScreen() {$/;"	f	package:nsfrontend
compileError	internal/compiler/scanner.go	/^func (s *scanner) compileError(msg string, args ...any) {$/;"	f	struct:compiler.scanner
compiler	internal/compiler/errors.go	/^package compiler$/;"	p
compiler	internal/compiler/parseRange.go	/^package compiler$/;"	p
compiler	internal/compiler/parseRead.go	/^package compiler$/;"	p
compiler	internal/compiler/parseType.go	/^package compiler$/;"	p
compiler	internal/compiler/parseWrite.go	/^package compiler$/;"	p
compiler	internal/compiler/parser.go	/^package compiler$/;"	p
compiler	internal/compiler/scanner.go	/^package compiler$/;"	p
compiler	internal/compiler/tokens.go	/^package compiler$/;"	p
compiler	internal/compiler/typeParse.go	/^package compiler$/;"	p
createDbFolder	internal/numstore/database.go	/^func createDbFolder(v Database) error {$/;"	f	package:numstore	typeref:typename:error
createDbMetaFile	internal/numstore/database.go	/^func createDbMetaFile(v Database) error {$/;"	f	package:numstore	typeref:typename:error
createVarFolder	internal/numstore/variable.go	/^func createVarFolder(dbname, vname string) error {$/;"	f	package:numstore	typeref:typename:error
createVarMetaFile	internal/numstore/variable.go	/^func createVarMetaFile(dbname string, v VariableMeta) error {$/;"	f	package:numstore	typeref:typename:error
cur	internal/compiler/parser.go	/^	cur     int$/;"	m	struct:compiler.parser	typeref:typename:int
current	internal/compiler/scanner.go	/^	current int$/;"	m	struct:compiler.scanner	typeref:typename:int
data	internal/compiler/scanner.go	/^	data    string$/;"	m	struct:compiler.scanner	typeref:typename:string
dataBuffer	internal/numstore/variable.go	/^	dataBuffer []byte$/;"	m	struct:numstore.WritingVariable	typeref:typename:[]byte
dbExistsAndValid	internal/numstore/database.go	/^func dbExistsAndValid(d Database) (bool, error) {$/;"	f	package:numstore	typeref:typename:(bool, error)
dbFolderName	internal/numstore/database.go	/^func dbFolderName(d Database) string {$/;"	f	package:numstore	typeref:typename:string
dbMetaFileName	internal/numstore/database.go	/^func dbMetaFileName(d Database) string {$/;"	f	package:numstore	typeref:typename:string
dbname	internal/numstore/writing.go	/^	dbname    string$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:string
dbname	internal/numstore/writing.go	/^	dbname    string$/;"	m	struct:numstore.WriteContext	typeref:typename:string
debugLogger	internal/logging/logging.go	/^	debugLogger = log.New(os.Stdout, "[DEBUG] ", 0)$/;"	v	package:logging
dimRange	internal/compiler/parseRange.go	/^type dimRange struct {$/;"	s	package:compiler
displayHelp	internal/frontend/shell.go	/^func displayHelp() {$/;"	f	package:nsfrontend
dtype	foo/bar/meta.json	/^{"name":"bar","dtype":"U64","shape":[]}/;"	s
dtype	foo/baz/meta.json	/^{"name":"baz","dtype":"U32","shape":[]}/;"	s
dtype	foo/fiz/meta.json	/^{"name":"fiz","dtype":"U32","shape":[]}/;"	s
enableAsserts	internal/utils/assert.go	/^const enableAsserts = true$/;"	c	package:utils
errorLogger	internal/logging/logging.go	/^	errorLogger = log.New(os.Stderr, "[ERROR] ", 0)$/;"	v	package:logging
expect	internal/compiler/parser.go	/^func (p *parser) expect(t tokenType) (token, bool) {$/;"	f	struct:compiler.parser	typeref:typename:(token, bool)
handleCmd	internal/frontend/common.go	/^func handleCmd(cmd string) {$/;"	f	package:nsfrontend
handleTokClose	internal/compiler/parser.go	/^func (t *parser) handleTokClose() error {$/;"	f	struct:compiler.parser	typeref:typename:error
handleTokCreate	internal/compiler/parser.go	/^func (t *parser) handleTokCreate() {$/;"	f	struct:compiler.parser
handleTokDelete	internal/compiler/parser.go	/^func (t *parser) handleTokDelete() {$/;"	f	struct:compiler.parser
handleTokOpen	internal/compiler/parser.go	/^func (t *parser) handleTokOpen() error {$/;"	f	struct:compiler.parser	typeref:typename:error
handleTokRead	internal/compiler/parser.go	/^func (t *parser) handleTokRead() error {$/;"	f	struct:compiler.parser	typeref:typename:error
handleTokTake	internal/compiler/parser.go	/^func (t *parser) handleTokTake() error {$/;"	f	struct:compiler.parser	typeref:typename:error
handleTokWrite	internal/compiler/parser.go	/^func (t *parser) handleTokWrite() error {$/;"	f	struct:compiler.parser	typeref:typename:error
infoLogger	internal/logging/logging.go	/^	infoLogger  = log.New(os.Stdout, "[INFO]  ", 0)$/;"	v	package:logging
interpretRange	internal/numstore/range.go	/^func interpretRange(toks []parse_tok, stack []int) (looseRange, error) {$/;"	f	package:numstore	typeref:typename:(looseRange, error)
isEnd	internal/compiler/parser.go	/^func (t parser) isEnd() bool {$/;"	f	struct:compiler.parser	typeref:typename:bool
isEnd	internal/compiler/scanner.go	/^func (s scanner) isEnd() bool {$/;"	f	struct:compiler.scanner	typeref:typename:bool
isError	internal/compiler/parser.go	/^	isError bool$/;"	m	struct:compiler.parser	typeref:typename:bool
isError	internal/compiler/scanner.go	/^	isError bool$/;"	m	struct:compiler.scanner	typeref:typename:bool
line	internal/compiler/scanner.go	/^	line    int$/;"	m	struct:compiler.scanner	typeref:typename:int
line	internal/compiler/tokens.go	/^	line  int$/;"	m	struct:compiler.token	typeref:typename:int
logLevel	internal/logging/logging.go	/^const logLevel = TRACE$/;"	c	package:logging
logging	internal/logging/logging.go	/^package logging$/;"	p
looseRange	internal/numstore/range.go	/^type looseRange struct {$/;"	s	package:numstore
looseRangePromote	internal/numstore/range.go	/^func looseRangePromote(s looseRange, arrLen uint64) Range {$/;"	f	package:numstore	typeref:typename:Range
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
name	foo/bar/meta.json	/^{"name":"bar","dtype":"U64","shape":[]}/;"	s
name	foo/baz/meta.json	/^{"name":"baz","dtype":"U32","shape":[]}/;"	s
name	foo/fiz/meta.json	/^{"name":"fiz","dtype":"U32","shape":[]}/;"	s
name	foo/meta.json	/^{"name":"foo"}/;"	s
nextChar	internal/compiler/scanner.go	/^func (s *scanner) nextChar() byte {$/;"	f	struct:compiler.scanner	typeref:typename:byte
nextIsEnd	internal/compiler/scanner.go	/^func (s scanner) nextIsEnd() bool {$/;"	f	struct:compiler.scanner	typeref:typename:bool
nextToken	internal/compiler/parser.go	/^func (t *parser) nextToken() (token, bool) {$/;"	f	struct:compiler.parser	typeref:typename:(token, bool)
nserror	internal/nserror/nserror.go	/^package nserror$/;"	p
nsfrontend	internal/frontend/common.go	/^package nsfrontend$/;"	p
nsfrontend	internal/frontend/file.go	/^package nsfrontend$/;"	p
nsfrontend	internal/frontend/shell.go	/^package nsfrontend$/;"	p
nsfrontend	main.go	/^	nsfrontend "github.com\/lincketheo\/numstore\/internal\/frontend"$/;"	P	package:github.com/lincketheo/numstore/internal/frontend
numstore	internal/numstore/database.go	/^package numstore$/;"	p
numstore	internal/numstore/nstypes.go	/^package numstore$/;"	p
numstore	internal/numstore/property.go	/^package numstore$/;"	p
numstore	internal/numstore/range.go	/^package numstore$/;"	p
numstore	internal/numstore/reader.go	/^package numstore$/;"	p
numstore	internal/numstore/variable.go	/^package numstore$/;"	p
numstore	internal/numstore/writing.go	/^package numstore$/;"	p
parseArray	internal/compiler/parseType.go	/^func (p *parser) parseArray() (numstore.Type, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.Type, bool)
parseEnum	internal/compiler/parseType.go	/^func (p *parser) parseEnum() (numstore.EnumType, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.EnumType, bool)
parseIdent	internal/compiler/scanner.go	/^func (s *scanner) parseIdent() tokenType {$/;"	f	struct:compiler.scanner	typeref:typename:tokenType
parseNumber	internal/compiler/scanner.go	/^func (s *scanner) parseNumber() tokenType {$/;"	f	struct:compiler.scanner	typeref:typename:tokenType
parsePrimitive	internal/compiler/parseType.go	/^func (p *parser) parsePrimitive() (numstore.PrimitiveType, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.PrimitiveType, bool)
parseRange	internal/numstore/range.go	/^func parseRange(str string) ([]parse_tok, []int, error) {$/;"	f	package:numstore	typeref:typename:([]parse_tok, []int, error)
parseReadFormat	internal/compiler/parseRead.go	/^func (p *parser) parseReadFormat() {$/;"	f	unknown:compiler.parser
parseStrictArray	internal/compiler/parseType.go	/^func (p *parser) parseStrictArray() (numstore.StrictArrayType, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.StrictArrayType, bool)
parseString	internal/compiler/scanner.go	/^func (s *scanner) parseString() {$/;"	f	struct:compiler.scanner
parseStructOrUnion	internal/compiler/parseType.go	/^func (p *parser) parseStructOrUnion(prefixTok tokenType) (map[string]numstore.Type, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(map[string]numstore.Type, bool)
parseType	internal/compiler/parseType.go	/^func (p *parser) parseType() (numstore.Type, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.Type, bool)
parseVarArray	internal/compiler/parseType.go	/^func (p *parser) parseVarArray() (numstore.VarArrayType, bool) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.VarArrayType, bool)
parseWriteFormat	internal/compiler/parseWrite.go	/^func (p *parser) parseWriteFormat() (numstore.WriteFormat, error) {$/;"	f	unknown:compiler.parser	typeref:typename:(numstore.WriteFormat, error)
parseWriteFormatList	internal/compiler/parseWrite.go	/^func (p *parser) parseWriteFormatList() ([][]string, error) {$/;"	f	unknown:compiler.parser	typeref:typename:([][]string, error)
parseWriteFormatTuple	internal/compiler/parseWrite.go	/^func (p *parser) parseWriteFormatTuple() ([]string, error) {$/;"	f	unknown:compiler.parser	typeref:typename:([]string, error)
parse_tok	internal/numstore/range.go	/^type parse_tok int$/;"	t	package:numstore	typeref:typename:int
parser	internal/compiler/parser.go	/^type parser struct {$/;"	s	package:compiler
parserError	internal/compiler/parser.go	/^func (t *parser) parserError(exp ...tokenType) {$/;"	f	struct:compiler.parser
peek2Char	internal/compiler/scanner.go	/^func (s scanner) peek2Char() byte {$/;"	f	struct:compiler.scanner	typeref:typename:byte
peekChar	internal/compiler/scanner.go	/^func (s scanner) peekChar() byte {$/;"	f	struct:compiler.scanner	typeref:typename:byte
peekToken	internal/compiler/parser.go	/^func (t parser) peekToken() (token, bool) {$/;"	f	struct:compiler.parser	typeref:typename:(token, bool)
primitiveType	internal/numstore/nstypes.go	/^type primitiveType uint8$/;"	t	package:numstore	typeref:typename:uint8
primitiveTypeSizeof	internal/numstore/nstypes.go	/^func primitiveTypeSizeof(pt primitiveType) uint32 {$/;"	f	package:numstore	typeref:typename:uint32
propTypeRegistry	internal/numstore/property.go	/^var propTypeRegistry = make(map[string]PropertyTypeFactory)$/;"	v	package:numstore
ranges	internal/compiler/parseRange.go	/^  ranges []dimRange$/;"	m	struct:compiler.arrRange	typeref:typename:[]dimRange
scanNextToken	internal/compiler/scanner.go	/^func (s *scanner) scanNextToken() token {$/;"	f	struct:compiler.scanner	typeref:typename:token
scanNextTokenType	internal/compiler/scanner.go	/^func (s *scanner) scanNextTokenType() tokenType {$/;"	f	struct:compiler.scanner	typeref:typename:tokenType
scanner	internal/compiler/scanner.go	/^type scanner struct {$/;"	s	package:compiler
scannerCreate	internal/compiler/scanner.go	/^func scannerCreate(_data string) scanner {$/;"	f	package:compiler	typeref:typename:scanner
shape	foo/bar/meta.json	/^{"name":"bar","dtype":"U64","shape":[]}/;"	a
shape	foo/baz/meta.json	/^{"name":"baz","dtype":"U32","shape":[]}/;"	a
shape	foo/fiz/meta.json	/^{"name":"fiz","dtype":"U32","shape":[]}/;"	a
skipWhitespace	internal/compiler/scanner.go	/^func (s *scanner) skipWhitespace() {$/;"	f	struct:compiler.scanner
srangeToRange	internal/numstore/range.go	/^func srangeToRange(s int64, isSPresent bool, dflt uint64, arrLen uint64) uint64 {$/;"	f	package:numstore	typeref:typename:uint64
start	internal/compiler/parseRange.go	/^	start        int$/;"	m	struct:compiler.dimRange	typeref:typename:int
start	internal/compiler/scanner.go	/^	start   int$/;"	m	struct:compiler.scanner	typeref:typename:int
start	internal/numstore/range.go	/^	start        int64$/;"	m	struct:numstore.looseRange	typeref:typename:int64
start	internal/numstore/range.go	/^	start uint64$/;"	m	struct:numstore.Range	typeref:typename:uint64
startPresent	internal/compiler/parseRange.go	/^	startPresent bool$/;"	m	struct:compiler.dimRange	typeref:typename:bool
startPresent	internal/numstore/range.go	/^	startPresent bool$/;"	m	struct:numstore.looseRange	typeref:typename:bool
step	internal/compiler/parseRange.go	/^	step         int$/;"	m	struct:compiler.dimRange	typeref:typename:int
step	internal/numstore/range.go	/^	step         int32$/;"	m	struct:numstore.looseRange	typeref:typename:int32
step	internal/numstore/range.go	/^	step  int32$/;"	m	struct:numstore.Range	typeref:typename:int32
stepPresent	internal/compiler/parseRange.go	/^	stepPresent  bool$/;"	m	struct:compiler.dimRange	typeref:typename:bool
stepPresent	internal/numstore/range.go	/^	stepPresent  bool$/;"	m	struct:numstore.looseRange	typeref:typename:bool
stop	internal/compiler/parseRange.go	/^	stop         int$/;"	m	struct:compiler.dimRange	typeref:typename:int
stop	internal/numstore/range.go	/^	stop         int64$/;"	m	struct:numstore.looseRange	typeref:typename:int64
stop	internal/numstore/range.go	/^	stop  uint64$/;"	m	struct:numstore.Range	typeref:typename:uint64
stopPresent	internal/compiler/parseRange.go	/^	stopPresent  bool$/;"	m	struct:compiler.dimRange	typeref:typename:bool
stopPresent	internal/numstore/range.go	/^	stopPresent  bool$/;"	m	struct:numstore.looseRange	typeref:typename:bool
tfd	internal/numstore/variable.go	/^	tfd        *os.File$/;"	m	struct:numstore.WritingVariable	typeref:typename:*os.File
timeBuffer	internal/numstore/variable.go	/^	timeBuffer []byte$/;"	m	struct:numstore.WritingVariable	typeref:typename:[]byte
toWrite	internal/numstore/writing.go	/^	toWrite   int$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:int
toWrite	internal/numstore/writing.go	/^	toWrite   int$/;"	m	struct:numstore.WriteContext	typeref:typename:int
token	internal/compiler/tokens.go	/^type token struct {$/;"	s	package:compiler
tokenType	internal/compiler/tokens.go	/^type tokenType int$/;"	t	package:compiler	typeref:typename:int
tokens	internal/compiler/parser.go	/^	tokens  []token$/;"	m	struct:compiler.parser	typeref:typename:[]token
traceLogger	internal/logging/logging.go	/^	traceLogger = log.New(os.Stdout, "[TRACE] ", 0)$/;"	v	package:logging
ttype	internal/compiler/tokens.go	/^	ttype tokenType$/;"	m	struct:compiler.token	typeref:typename:tokenType
typeStartTokens	internal/compiler/parseType.go	/^var typeStartTokens = []tokenType{TOK_UNION, TOK_STRUCT, TOK_ENUM, TOK_LEFT_BRACKET, TOK_PRIM}$/;"	v	package:compiler
unmarshalType	internal/numstore/nstypes.go	/^func unmarshalType(raw json.RawMessage) (Type, error) {$/;"	f	package:numstore	typeref:typename:(Type, error)
utils	internal/utils/arrays.go	/^package utils$/;"	p
utils	internal/utils/assert.go	/^package utils$/;"	p
utils	internal/utils/config.go	/^package utils$/;"	p
utils	internal/utils/fs.go	/^package utils$/;"	p
utils	internal/utils/numbers.go	/^package utils$/;"	p
utils	internal/utils/reflection.go	/^package utils$/;"	p
utils	internal/utils/strings.go	/^package utils $/;"	p
value	internal/compiler/tokens.go	/^	value string$/;"	m	struct:compiler.token	typeref:typename:string
varDataFileName	internal/numstore/variable.go	/^func varDataFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varExistsAndValid	internal/numstore/variable.go	/^func varExistsAndValid(db, v string) (bool, error) {$/;"	f	package:numstore	typeref:typename:(bool, error)
varFolderName	internal/numstore/variable.go	/^func varFolderName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varMetaFileName	internal/numstore/variable.go	/^func varMetaFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
varTimeFileName	internal/numstore/variable.go	/^func varTimeFileName(db, vname string) string {$/;"	f	package:numstore	typeref:typename:string
variables	internal/numstore/writing.go	/^	variables [][]VariableMeta$/;"	m	struct:numstore.WriteContext	typeref:typename:[][]VariableMeta
variables	internal/numstore/writing.go	/^	variables [][]WritingVariable$/;"	m	struct:numstore.OpenWriteContext	typeref:typename:[][]WritingVariable
vfd	internal/numstore/variable.go	/^	vfd        *os.File$/;"	m	struct:numstore.WritingVariable	typeref:typename:*os.File
vname	internal/numstore/reader.go	/^	vname string$/;"	m	struct:numstore.VariableSlice	typeref:typename:string
warnLogger	internal/logging/logging.go	/^	warnLogger  = log.New(os.Stdout, "[WARN]  ", 0)$/;"	v	package:logging
